---
import CustomerCard from 'components/CustomerCard.astro';
import CustomerDetail from 'components/CustomerDetail.astro';
import { CUSTOMERS } from 'consts/customers';
import { subTitleCustomer, titleCustomer } from 'consts/pagesTitle';
import type { Customer } from 'types/customer';

const initialCustomer = CUSTOMERS[0] as Customer;
---

<section
  id="customers"
  class="relative flex w-full max-w-[1200px] scroll-mt-28 flex-col items-center justify-center gap-10 px-2 py-20 sm:py-40 md:scroll-mt-36 md:gap-20"
  aria-label="Sección de clientes"
  info-customers={JSON.stringify(CUSTOMERS)}
>
  <header class="flex w-[90%] flex-col items-center justify-center gap-4 text-center md:w-[100%]">
    <h2 class="text-secondary text-2xl font-bold uppercase duration-300 sm:text-4xl md:text-5xl">
      {titleCustomer}
    </h2>
    <h3 class="text-primary text-sm font-medium sm:text-lg md:text-3xl">{subTitleCustomer}</h3>
  </header>

  <!-- Se asigna el cliente principal -->
  <CustomerDetail customer={initialCustomer} />

  <!-- Cinta infinita en movimiento -->
  <main class="customer-marquee-container relative w-full overflow-hidden rounded-xl py-10">
    <div class="customer-marquee flex">
      {CUSTOMERS.map((customer) => <CustomerCard customer={customer} />)}
      {CUSTOMERS.map((customer) => <CustomerCard customer={customer} />)}
    </div>
  </main>
</section>

<style>
  /* ✅ Optimización: Gradientes para efecto fade en los bordes */
  .customer-marquee-container::before,
  .customer-marquee-container::after {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    width: 200px;
    z-index: 10;
    pointer-events: none;
  }

  .customer-marquee-container::before {
    left: 0;
    background: linear-gradient(90deg, #00252d 0%, transparent 100%);
  }

  .customer-marquee-container::after {
    right: 0;
    background: linear-gradient(270deg, #00252d 0%, transparent 100%);
  }

  /* ✅ Animación optimizada usando solo transform para evitar reflows */
  .customer-marquee {
    animation: scroll-left 20s linear infinite;
    width: max-content;
    /* ✅ Performance hints para el navegador */
    will-change: transform;
    /* ✅ Forzar layer de composición para mejor performance */
    transform: translateZ(0);
  }

  /* ✅ Animación optimizada usando solo transform */
  @keyframes scroll-left {
    0% {
      transform: translateX(0);
    }
    100% {
      transform: translateX(-50%);
    }
  }

  /* ✅ Hover optimizado */
  .customer-marquee:hover {
    animation-play-state: paused;
  }

  /* ✅ Cards de customers optimizadas */
  .customer-marquee > article {
    transition: transform 0.3s ease;
    will-change: transform;
  }

  .customer-marquee > article:hover {
    transform: scale(1.05);
  }

  /* ✅ Mejorar performance de responsive */
  @media (max-width: 768px) {
    .customer-marquee {
      animation-duration: 15s;
    }
  }

  /* ✅ Respetar preferencias de accesibilidad */
  @media (prefers-reduced-motion: reduce) {
    .customer-marquee {
      animation: none;
    }
    
    .customer-marquee > article {
      transition: none;
    }
  }
</style>

<script>
  import type { Customer, SocialMedia } from 'types/customer';
  import { logoSvgMap, socialIconsMap, type SocialPlatform } from 'consts/iconsMap';

  // ✅ Usar DocumentFragment para batch DOM operations
  function updateLogoCustomer(logoCustomer: HTMLElement, customer: any, logoSvgMap: any) {
    requestAnimationFrame(() => {
      const logoSrc = logoSvgMap[customer.id as keyof typeof logoSvgMap];
      if (logoSrc) {
        // Crear img element en lugar de innerHTML
        const existingImg = logoCustomer.querySelector('img');
        if (existingImg) {
          // Reutilizar elemento existente para evitar reflow
          existingImg.src = logoSrc;
          existingImg.alt = `Logo de ${customer.name}`;
        } else {
          // Crear nuevo elemento solo si no existe
          const imgElement = document.createElement('img');
          imgElement.src = logoSrc;
          imgElement.alt = `Logo de ${customer.name}`;
          imgElement.loading = 'lazy';
          imgElement.className = 'w-full h-full object-contain';
          logoCustomer.replaceChildren(imgElement);
        }
      }
    });
  }

  function updateSocialCustomer(socialMedia: SocialMedia, socialCustomer: HTMLElement) {
    requestAnimationFrame(() => {
      // ✅ Usar DocumentFragment para batching
      const fragment = document.createDocumentFragment();

      Object.entries(socialMedia).forEach(([platform, url]) => {
        if (url && platform in socialIconsMap) {
          const iconSvg = socialIconsMap[platform as SocialPlatform];
          if (iconSvg) {
            const link = document.createElement('a');
            link.href = url;
            link.target = '_blank';
            link.rel = 'noopener noreferrer';
            link.className = 'duration-300 hover:scale-105';
            link.setAttribute('aria-label', `Visitanos en ${platform}`);
            link.innerHTML = iconSvg;

            const svgElement = link.querySelector('svg');
            svgElement?.classList.add('h-8', 'w-8');

            fragment.appendChild(link);
          }
        }
      });

      // ✅ Una sola operación DOM en lugar de innerHTML = '' + múltiples appendChild
      socialCustomer.replaceChildren(fragment);
    });
  }

  function updateCustomerDetail(customer: Customer) {
    const detailCustomer = document.querySelector<HTMLElement>("[data-customer='detail-component']");
    const nameCustomer = document.querySelector<HTMLElement>("[data-customer='name-customer']");
    const industryCustomer = document.querySelector<HTMLElement>(
      "[data-customer='industry-customer']",
    );
    const logoCustomer = document.querySelector<HTMLElement>("[data-customer='logo-customer']");
    const descriptionCustomer = document.querySelector<HTMLElement>(
      "[data-customer='description-customer']",
    );
    const locationCustomer = document.querySelector<HTMLElement>(
      "[data-customer='location-customer']",
    );
    const socialCustomer = document.querySelector<HTMLElement>("[data-customer='social-customer']");

    if (detailCustomer) {
      detailCustomer.classList.add('is-changing');

      setTimeout(() => {
        // Actualizar el texto
        if (nameCustomer) nameCustomer.textContent = customer.name;
        if (industryCustomer) industryCustomer.textContent = customer.industry;
        if (descriptionCustomer) descriptionCustomer.textContent = customer.description;
        if (locationCustomer) locationCustomer.textContent = customer.location;

        // ✅ Actualizar el logo de forma optimizada
        if (logoCustomer) {
          updateLogoCustomer(logoCustomer, customer, logoSvgMap);
        }

        // ✅ Actualizar redes sociales de forma optimizada
        if (socialCustomer) {
          updateSocialCustomer(customer.socialMedia, socialCustomer);
        }

        detailCustomer?.classList.remove('is-changing');
      }, 300);
    }
  }

  // ✅ Defer script execution hasta que el elemento sea visible o la página esté idle
  function initializeCustomerInteraction() {
    const customerSection = document.querySelector<HTMLElement>('#customers');
    if (!customerSection) return;

    // obtención de los mapas de datos
    const customersData: Customer[] = JSON.parse(
      customerSection.getAttribute('info-customers') || '[]',
    );

    // ✅ Usar event delegation en lugar de múltiples listeners para evitar problemas con IDs duplicados
    const customerMarquee = document.querySelector('.customer-marquee');
    if (customerMarquee) {
      customerMarquee.addEventListener('click', (event) => {
        // Buscar el customer card más cercano
        const customerCard = (event.target as HTMLElement).closest('[data-target]') as HTMLElement;
        if (customerCard) {
          const clickedId = customerCard.id;
          const selectedCustomer = customersData.find((item: Customer) => item.id === clickedId);

          if (selectedCustomer) {
            updateCustomerDetail(selectedCustomer);
          }
        }
      });
    }
  }

  // ✅ Usar requestIdleCallback para ejecutar cuando el browser esté idle
  document.addEventListener('astro:page-load', () => {
    if ('requestIdleCallback' in window) {
      requestIdleCallback(initializeCustomerInteraction, { timeout: 2000 });
    } else {
      // Fallback para browsers que no soportan requestIdleCallback
      setTimeout(initializeCustomerInteraction, 100);
    }
  });
</script>
